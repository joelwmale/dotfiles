# Use vs to open Cursor (VS Code fork with AI)
vs () { VSCODE_CWD="$PWD" open -n -b "com.todesktop.230313mzl4w4u92" --args $* ;}

v() {
    (cd ~/Code/cli-l && php artisan security:audit)
}

unalias p 2>/dev/null

p() {
    if [[ -f "composer.json" ]]; then
        if composer run --list 2>/dev/null | grep -q "^\s*test\s"; then
            composer run test
        else
            ./vendor/bin/pest
        fi
    else
        echo "No composer.json found in current directory"
        return 1
    fi
}

gho() {
    # Check if the current directory is a Git repository
    if [[ ! -d .git ]]; then
        echo "Error: Not a Git repository."
        return 1
    fi

    # Extract the 'origin' URL from the .git configuration
    GIT_URL=$(git config --get remote.origin.url)

    # Check if the URL is valid
    if [[ -z "$GIT_URL" ]]; then
        echo "Error: No remote 'origin' URL found."
        return 1
    fi

    # Transform the URL into a browser-friendly format
    # Handle both SSH and HTTPS URLs
    if [[ "$GIT_URL" == git@* ]]; then
        # Convert SSH URL (e.g., git@github.com:org/repo.git) to HTTPS
        BROWSER_URL=$(echo "$GIT_URL" | sed -E 's/git@(.*):/https:\/\/\1\//' | sed 's/\.git$//')
    elif [[ "$GIT_URL" == https://* ]]; then
        # Remove .git if it's an HTTPS URL
        BROWSER_URL=$(echo "$GIT_URL" | sed 's/\.git$//')
    else
        echo "Error: Unsupported remote URL format."
        return 1
    fi

    # Open the URL in the default browser
    echo "Opening $BROWSER_URL..."
    open "$BROWSER_URL"
}

unalias gss 2>/dev/null  # Remove alias if it exists

gss() {
    local targetDir
    targetDir=$(php ~/Code/cli/swap.php)  # No spaces around '='

    if [ -d "$targetDir" ]; then  # Check if the directory exists
        cd "$targetDir" || return 1
        echo "Switched to $targetDir"
    else
        echo -e "\033[31mError: Target directory does not exist.\033[0m"
        echo "Directory: $targetDir"
    fi
}

composer-link() {
    # Check if the directory is provided and exists
    if [[ -z "$1" || ! -d "$1" ]]; then
        echo "Usage: composer-link <path-to-package-directory>"
        return 1
    fi

    # Define the path to the package's composer.json file
    PACKAGE_COMPOSER_JSON="$1/composer.json"

    # Check if composer.json exists in the given directory
    if [[ ! -f "$PACKAGE_COMPOSER_JSON" ]]; then
        echo "Error: composer.json not found in the specified directory."
        return 1
    fi

    # Extract the 'name' field from the package's composer.json
    PACKAGE_NAME=$(jq -r '.name' "$PACKAGE_COMPOSER_JSON" 2>/dev/null)

    # Verify the name was successfully extracted
    if [[ -z "$PACKAGE_NAME" || "$PACKAGE_NAME" == "null" ]]; then
        echo "Error: Unable to find a valid 'name' in $PACKAGE_COMPOSER_JSON."
        return 1
    fi

    # Add the repository to the current project's composer.json
    composer config repositories.local '{"type": "path", "url": "'"$1"'"}' --file composer.json

    # Run composer require using the extracted package name
    composer require "$PACKAGE_NAME":@dev

    echo "Successfully linked and required package: $PACKAGE_NAME"
}


function tc() {
   if [ -f app/Console/Commands/TestCommand.php ]; then
      pa test:command
   else
      pa make:command TestCommand
      sed -i 's/command:name/test:command/' app/Console/Commands/TestCommand.php
   fi
}

function gitclean()
{
   !f() { local targetBranch=${1:-master} && git checkout -q $targetBranch && git branch --merged | grep -v "\*" | xargs -n 1 git branch -d && git for-each-ref refs/heads/ "--format=%(refname:short)" | while read branch; do mergeBase=$(git merge-base $targetBranch $branch) && [[ $(git cherry $targetBranch $(git commit-tree $(git rev-parse $branch^{tree}) -p $mergeBase -m _)) == "-"* ]] && git branch -D $branch; done; }; f
}

function dc() {
   # work out the docker compose container id using the docker-compose file
   containerId=$(docker-compose ps -q $1)

   # if the container id is empty, then the container is not running
   if [ -z "$containerId" ]; then
      echo "Container $1 is not running"
      return
   fi

   # now start a shell in the container
   docker exec -it $containerId /bin/bash
}

# Create a new directory and enter it
function mkd() {
   mkdir -p "$@" && cd "$@"
}

function weather() {
   ocal city="${1:-Brisbane}"
   curl http://wttr.in/${city// /+}\?F
}

#  Commit everything
function commit() {
  commitMessage="$*"

  git add .

  if [ "$commitMessage" = "" ]; then
     # Start spinner in background (suppress job control messages)
     {
       spinner="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
       while true; do
         for (( i=0; i<${#spinner}; i++ )); do
           printf "\r${spinner:$i:1} Generating commit message..."
           sleep 0.1
         done
       done
     } &!
     spinner_pid=$!

     # Cleanup function for interrupt
     cleanup() {
       { kill $spinner_pid; wait $spinner_pid; } 2>/dev/null
       printf "\r\033[K"
       trap - INT
       return 1
     }
     trap cleanup INT

     # Get diff with size limit, include stat summary for context
     diff_input=$(echo "=== Summary ===" && git diff --cached --stat && echo -e "\n=== Diff (truncated if large) ===" && git diff --cached | head -c 50000)
     commitMessage=$(echo "$diff_input" | claude -p "Write a single-line commit message for this diff. Output ONLY the message, no quotes, no explanation, no markdown.")

     # Stop spinner and clear line
     trap - INT
     { kill $spinner_pid; wait $spinner_pid; } 2>/dev/null
     printf "\r\033[K"

     git commit -m "$commitMessage"
     return
  fi

  eval "git commit -a -m '${commitMessage}'"
}

function db () {
   [ ! -f .env ] && { echo "No .env file found."; exit 1; }

   DB_CONNECTION=$(grep DB_CONNECTION .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
   DB_HOST=$(grep DB_HOST .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
   DB_PORT=$(grep DB_PORT .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
   DB_DATABASE=$(grep DB_DATABASE .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
   DB_USERNAME=$(grep DB_USERNAME .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)
   DB_PASSWORD=$(grep DB_PASSWORD .env | grep -v -e '^\s*#' | cut -d '=' -f 2-)

   DB_URL="${DB_CONNECTION}://${DB_USERNAME}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_DATABASE}"

   echo "Opening ${DB_URL}"
   open $DB_URL
}

function scheduler () {
    while :; do
        php artisan schedule:run
	echo "Sleeping 60 seconds..."
        sleep 60
    done
}

function silent() {
   "$@" >& /dev/null
}
